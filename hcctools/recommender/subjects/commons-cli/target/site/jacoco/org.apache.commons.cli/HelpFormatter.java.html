<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelpFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons CLI</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.cli</a> &gt; <span class="el_source">HelpFormatter.java</span></div><h1>HelpFormatter.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.cli;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

/**
 * A formatter of help messages for command line options.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 * 
 * &lt;pre&gt;
 * Options options = new Options();
 * options.addOption(OptionBuilder.withLongOpt(&quot;file&quot;)
 *                                .withDescription(&quot;The file to be processed&quot;)
 *                                .hasArg()
 *                                .withArgName(&quot;FILE&quot;)
 *                                .isRequired()
 *                                .create('f'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;version&quot;)
 *                                .withDescription(&quot;Print the version of the application&quot;)
 *                                .create('v'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;help&quot;).create('h'));
 * 
 * String header = &quot;Do something useful with an input file\n\n&quot;;
 * String footer = &quot;\nPlease report issues at http://example.com/issues&quot;;
 * 
 * HelpFormatter formatter = new HelpFormatter();
 * formatter.printHelp(&quot;myapp&quot;, header, options, footer, true);
 * &lt;/pre&gt;
 * 
 * This produces the following output:
 * 
 * &lt;pre&gt;
 * usage: myapp -f &amp;lt;FILE&amp;gt; [-h] [-v]
 * Do something useful with an input file
 * 
 *  -f,--file &amp;lt;FILE&amp;gt;   The file to be processed
 *  -h,--help
 *  -v,--version       Print the version of the application
 * 
 * Please report issues at http://example.com/issues
 * &lt;/pre&gt;
 * 
 * @version $Id$
 */
<span class="fc" id="L73">public class HelpFormatter</span>
{
    // --------------------------------------------------------------- Constants

    /** default number of characters per line */
    public static final int DEFAULT_WIDTH = 74;

    /** default padding to the left of each line */
    public static final int DEFAULT_LEFT_PAD = 1;

    /** number of space characters to be prefixed to each description line */
    public static final int DEFAULT_DESC_PAD = 3;

    /** the string to display at the beginning of the usage statement */
    public static final String DEFAULT_SYNTAX_PREFIX = &quot;usage: &quot;;

    /** default prefix for shortOpts */
    public static final String DEFAULT_OPT_PREFIX = &quot;-&quot;;

    /** default prefix for long Option */
    public static final String DEFAULT_LONG_OPT_PREFIX = &quot;--&quot;;

    /** 
     * default separator displayed between a long Option and its value
     * 
     * @since 1.3
     **/
    public static final String DEFAULT_LONG_OPT_SEPARATOR = &quot; &quot;;

    /** default name for an argument */
    public static final String DEFAULT_ARG_NAME = &quot;arg&quot;;

    // -------------------------------------------------------------- Attributes

    /**
     * number of characters per line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setWidth methods instead.
     */
<span class="fc" id="L113">    @Deprecated</span>
    public int defaultWidth = DEFAULT_WIDTH;

    /**
     * amount of padding to the left of each line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setLeftPadding methods instead.
     */
<span class="fc" id="L122">    @Deprecated</span>
    public int defaultLeftPad = DEFAULT_LEFT_PAD;

    /**
     * the number of characters of padding to be prefixed
     * to each description line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setDescPadding methods instead.
     */
<span class="fc" id="L132">    @Deprecated</span>
    public int defaultDescPad = DEFAULT_DESC_PAD;

    /**
     * the string to display at the beginning of the usage statement
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setSyntaxPrefix methods instead.
     */
<span class="fc" id="L141">    @Deprecated</span>
    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;

    /**
     * the new line string
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setNewLine methods instead.
     */
<span class="fc" id="L150">    @Deprecated</span>
<span class="fc" id="L151">    public String defaultNewLine = System.getProperty(&quot;line.separator&quot;);</span>

    /**
     * the shortOpt prefix
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setOptPrefix methods instead.
     */
<span class="fc" id="L159">    @Deprecated</span>
    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;

    /**
     * the long Opt prefix
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setLongOptPrefix methods instead.
     */
<span class="fc" id="L168">    @Deprecated</span>
    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;

    /**
     * the name of the argument
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setArgName methods instead.
     */
<span class="fc" id="L177">    @Deprecated</span>
    public String defaultArgName = DEFAULT_ARG_NAME;

    /**
     * Comparator used to sort the options when they output in help text
     * 
     * Defaults to case-insensitive alphabetical sorting by option key
     */
<span class="fc" id="L185">    protected Comparator&lt;Option&gt; optionComparator = new OptionComparator();</span>

    /** The separator displayed between the long option and its value. */
<span class="fc" id="L188">    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;</span>

    /**
     * Sets the 'width'.
     *
     * @param width the new value of 'width'
     */
    public void setWidth(int width)
    {
<span class="fc" id="L197">        this.defaultWidth = width;</span>
<span class="fc" id="L198">    }</span>

    /**
     * Returns the 'width'.
     *
     * @return the 'width'
     */
    public int getWidth()
    {
<span class="fc" id="L207">        return defaultWidth;</span>
    }

    /**
     * Sets the 'leftPadding'.
     *
     * @param padding the new value of 'leftPadding'
     */
    public void setLeftPadding(int padding)
    {
<span class="fc" id="L217">        this.defaultLeftPad = padding;</span>
<span class="fc" id="L218">    }</span>

    /**
     * Returns the 'leftPadding'.
     *
     * @return the 'leftPadding'
     */
    public int getLeftPadding()
    {
<span class="fc" id="L227">        return defaultLeftPad;</span>
    }

    /**
     * Sets the 'descPadding'.
     *
     * @param padding the new value of 'descPadding'
     */
    public void setDescPadding(int padding)
    {
<span class="fc" id="L237">        this.defaultDescPad = padding;</span>
<span class="fc" id="L238">    }</span>

    /**
     * Returns the 'descPadding'.
     *
     * @return the 'descPadding'
     */
    public int getDescPadding()
    {
<span class="fc" id="L247">        return defaultDescPad;</span>
    }

    /**
     * Sets the 'syntaxPrefix'.
     *
     * @param prefix the new value of 'syntaxPrefix'
     */
    public void setSyntaxPrefix(String prefix)
    {
<span class="fc" id="L257">        this.defaultSyntaxPrefix = prefix;</span>
<span class="fc" id="L258">    }</span>

    /**
     * Returns the 'syntaxPrefix'.
     *
     * @return the 'syntaxPrefix'
     */
    public String getSyntaxPrefix()
    {
<span class="fc" id="L267">        return defaultSyntaxPrefix;</span>
    }

    /**
     * Sets the 'newLine'.
     *
     * @param newline the new value of 'newLine'
     */
    public void setNewLine(String newline)
    {
<span class="fc" id="L277">        this.defaultNewLine = newline;</span>
<span class="fc" id="L278">    }</span>

    /**
     * Returns the 'newLine'.
     *
     * @return the 'newLine'
     */
    public String getNewLine()
    {
<span class="fc" id="L287">        return defaultNewLine;</span>
    }

    /**
     * Sets the 'optPrefix'.
     *
     * @param prefix the new value of 'optPrefix'
     */
    public void setOptPrefix(String prefix)
    {
<span class="fc" id="L297">        this.defaultOptPrefix = prefix;</span>
<span class="fc" id="L298">    }</span>

    /**
     * Returns the 'optPrefix'.
     *
     * @return the 'optPrefix'
     */
    public String getOptPrefix()
    {
<span class="fc" id="L307">        return defaultOptPrefix;</span>
    }

    /**
     * Sets the 'longOptPrefix'.
     *
     * @param prefix the new value of 'longOptPrefix'
     */
    public void setLongOptPrefix(String prefix)
    {
<span class="fc" id="L317">        this.defaultLongOptPrefix = prefix;</span>
<span class="fc" id="L318">    }</span>

    /**
     * Returns the 'longOptPrefix'.
     *
     * @return the 'longOptPrefix'
     */
    public String getLongOptPrefix()
    {
<span class="fc" id="L327">        return defaultLongOptPrefix;</span>
    }

    /**
     * Set the separator displayed between a long option and its value.
     * Ensure that the separator specified is supported by the parser used,
     * typically ' ' or '='.
     * 
     * @param longOptSeparator the separator, typically ' ' or '='.
     * @since 1.3
     */
    public void setLongOptSeparator(String longOptSeparator)
    {
<span class="fc" id="L340">        this.longOptSeparator = longOptSeparator;</span>
<span class="fc" id="L341">    }</span>

    /**
     * Returns the separator displayed between a long option and its value.
     * 
     * @return the separator
     * @since 1.3
     */
    public String getLongOptSeparator()
    {
<span class="fc" id="L351">        return longOptSeparator;</span>
    }

    /**
     * Sets the 'argName'.
     *
     * @param name the new value of 'argName'
     */
    public void setArgName(String name)
    {
<span class="fc" id="L361">        this.defaultArgName = name;</span>
<span class="fc" id="L362">    }</span>

    /**
     * Returns the 'argName'.
     *
     * @return the 'argName'
     */
    public String getArgName()
    {
<span class="fc" id="L371">        return defaultArgName;</span>
    }

    /**
     * Comparator used to sort the options when they output in help text.
     * Defaults to case-insensitive alphabetical sorting by option key.
     *
     * @return the {@link Comparator} currently in use to sort the options
     * @since 1.2
     */
    public Comparator&lt;Option&gt; getOptionComparator()
    {
<span class="fc" id="L383">        return optionComparator;</span>
    }

    /**
     * Set the comparator used to sort the options when they output in help text.
     * Passing in a null comparator will keep the options in the order they were declared.
     *
     * @param comparator the {@link Comparator} to use for sorting the options
     * @since 1.2
     */
    public void setOptionComparator(Comparator&lt;Option&gt; comparator)
    {
<span class="fc" id="L395">        this.optionComparator = comparator;</span>
<span class="fc" id="L396">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     */
    public void printHelp(String cmdLineSyntax, Options options)
    {
<span class="fc" id="L408">        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);</span>
<span class="fc" id="L409">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to 
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     * @param autoUsage whether to print an automatically generated
     * usage statement
     */
    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)
    {
<span class="nc" id="L423">        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);</span>
<span class="nc" id="L424">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)
    {
<span class="nc" id="L438">        printHelp(cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L439">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to 
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated
     * usage statement
     */
    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)
    {
<span class="nc" id="L455">        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);</span>
<span class="nc" id="L456">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)
    {
<span class="nc" id="L471">        printHelp(width, cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L472">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated 
     * usage statement
     */
    public void printHelp(int width, String cmdLineSyntax, String header,
                          Options options, String footer, boolean autoUsage)
    {
<span class="fc" id="L490">        PrintWriter pw = new PrintWriter(System.out);</span>

<span class="fc" id="L492">        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);</span>
<span class="fc" id="L493">        pw.flush();</span>
<span class="fc" id="L494">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     * @param footer the banner to display at the end of the help
     *
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, 
                          String header, Options options, int leftPad, 
                          int descPad, String footer)
    {
<span class="fc" id="L517">        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);</span>
<span class="fc" id="L518">    }</span>


    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated
     * usage statement
     *
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,
                          String header, Options options, int leftPad,
                          int descPad, String footer, boolean autoUsage)
    {
<span class="fc bfc" id="L544" title="All 4 branches covered.">        if (cmdLineSyntax == null || cmdLineSyntax.length() == 0)</span>
        {
<span class="fc" id="L546">            throw new IllegalArgumentException(&quot;cmdLineSyntax not provided&quot;);</span>
        }

<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (autoUsage)</span>
        {
<span class="fc" id="L551">            printUsage(pw, width, cmdLineSyntax, options);</span>
        }
        else
        {
<span class="fc" id="L555">            printUsage(pw, width, cmdLineSyntax);</span>
        }

<span class="fc bfc" id="L558" title="All 4 branches covered.">        if (header != null &amp;&amp; header.trim().length() &gt; 0)</span>
        {
<span class="fc" id="L560">            printWrapped(pw, width, header);</span>
        }

<span class="fc" id="L563">        printOptions(pw, width, options, leftPad, descPad);</span>

<span class="fc bfc" id="L565" title="All 4 branches covered.">        if (footer != null &amp;&amp; footer.trim().length() &gt; 0)</span>
        {
<span class="fc" id="L567">            printWrapped(pw, width, footer);</span>
        }
<span class="fc" id="L569">    }</span>

    /**
     * Prints the usage statement for the specified application.
     *
     * @param pw The PrintWriter to print the usage statement 
     * @param width The number of characters to display per line
     * @param app The application name
     * @param options The command line Options
     */
    public void printUsage(PrintWriter pw, int width, String app, Options options)
    {
        // initialise the string buffer
<span class="fc" id="L582">        StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(&quot; &quot;);</span>

        // create a list for processed option groups
<span class="fc" id="L585">        Collection&lt;OptionGroup&gt; processedGroups = new ArrayList&lt;OptionGroup&gt;();</span>

<span class="fc" id="L587">        List&lt;Option&gt; optList = new ArrayList&lt;Option&gt;(options.getOptions());</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L590">            Collections.sort(optList, getOptionComparator());</span>
        }
        // iterate over the options
<span class="fc bfc" id="L593" title="All 2 branches covered.">        for (Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
            // get the next Option
<span class="fc" id="L596">            Option option = it.next();</span>

            // check if the option is part of an OptionGroup
<span class="fc" id="L599">            OptionGroup group = options.getOptionGroup(option);</span>

            // if the option is part of a group 
<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (group != null)</span>
            {
                // and if the group has not already been processed
<span class="fc bfc" id="L605" title="All 2 branches covered.">                if (!processedGroups.contains(group))</span>
                {
                    // add the group to the processed list
<span class="fc" id="L608">                    processedGroups.add(group);</span>


                    // add the usage clause
<span class="fc" id="L612">                    appendOptionGroup(buff, group);</span>
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
<span class="fc" id="L622">                appendOption(buff, option, option.isRequired());</span>
            }

<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L627">                buff.append(&quot; &quot;);</span>
            }
<span class="fc" id="L629">        }</span>


        // call printWrapped
<span class="fc" id="L633">        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());</span>
<span class="fc" id="L634">    }</span>

    /**
     * Appends the usage clause for an OptionGroup to a StringBuffer.  
     * The clause is wrapped in square brackets if the group is required.
     * The display of the options is handled by appendOption
     * @param buff the StringBuffer to append to
     * @param group the group to append
     * @see #appendOption(StringBuffer,Option,boolean)
     */
    private void appendOptionGroup(StringBuffer buff, OptionGroup group)
    {
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if (!group.isRequired())</span>
        {
<span class="fc" id="L648">            buff.append(&quot;[&quot;);</span>
        }

<span class="fc" id="L651">        List&lt;Option&gt; optList = new ArrayList&lt;Option&gt;(group.getOptions());</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L654">            Collections.sort(optList, getOptionComparator());</span>
        }
        // for each option in the OptionGroup
<span class="fc bfc" id="L657" title="All 2 branches covered.">        for (Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
            // whether the option is required or not is handled at group level
<span class="fc" id="L660">            appendOption(buff, it.next(), true);</span>

<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L664">                buff.append(&quot; | &quot;);</span>
            }
        }

<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (!group.isRequired())</span>
        {
<span class="fc" id="L670">            buff.append(&quot;]&quot;);</span>
        }
<span class="fc" id="L672">    }</span>

    /**
     * Appends the usage clause for an Option to a StringBuffer.  
     *
     * @param buff the StringBuffer to append to
     * @param option the Option to append
     * @param required whether the Option is required or not
     */
    private void appendOption(StringBuffer buff, Option option, boolean required)
    {
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (!required)</span>
        {
<span class="fc" id="L685">            buff.append(&quot;[&quot;);</span>
        }

<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (option.getOpt() != null)</span>
        {
<span class="fc" id="L690">            buff.append(&quot;-&quot;).append(option.getOpt());</span>
        }
        else
        {
<span class="fc" id="L694">            buff.append(&quot;--&quot;).append(option.getLongOpt());</span>
        }
        
        // if the Option has a value and a non blank argname
<span class="fc bfc" id="L698" title="All 6 branches covered.">        if (option.hasArg() &amp;&amp; (option.getArgName() == null || option.getArgName().length() != 0))</span>
        {
<span class="fc bfc" id="L700" title="All 2 branches covered.">            buff.append(option.getOpt() == null ? longOptSeparator : &quot; &quot;);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">            buff.append(&quot;&lt;&quot;).append(option.getArgName() != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
        }
        
        // if the Option is not a required option
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (!required)</span>
        {
<span class="fc" id="L707">            buff.append(&quot;]&quot;);</span>
        }
<span class="fc" id="L709">    }</span>

    /**
     * Print the cmdLineSyntax to the specified writer, using the
     * specified width.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters per line for the usage statement.
     * @param cmdLineSyntax The usage statement.
     */
    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)
    {
<span class="fc" id="L721">        int argPos = cmdLineSyntax.indexOf(' ') + 1;</span>

<span class="fc" id="L723">        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);</span>
<span class="fc" id="L724">    }</span>

    /**
     * Print the help for the specified Options to the specified writer, 
     * using the specified width, left padding and description padding.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     */
    public void printOptions(PrintWriter pw, int width, Options options, 
                             int leftPad, int descPad)
    {
<span class="fc" id="L741">        StringBuffer sb = new StringBuffer();</span>

<span class="fc" id="L743">        renderOptions(sb, width, options, leftPad, descPad);</span>
<span class="fc" id="L744">        pw.println(sb.toString());</span>
<span class="fc" id="L745">    }</span>

    /**
     * Print the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(PrintWriter pw, int width, String text)
    {
<span class="fc" id="L756">        printWrapped(pw, width, 0, text);</span>
<span class="fc" id="L757">    }</span>

    /**
     * Print the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)
    {
<span class="fc" id="L769">        StringBuffer sb = new StringBuffer(text.length());</span>

<span class="fc" id="L771">        renderWrappedTextBlock(sb, width, nextLineTabStop, text);</span>
<span class="fc" id="L772">        pw.println(sb.toString());</span>
<span class="fc" id="L773">    }</span>

    // --------------------------------------------------------------- Protected

    /**
     * Render the specified Options and return the rendered Options
     * in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered Options into.
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)
    {
<span class="fc" id="L793">        final String lpad = createPadding(leftPad);</span>
<span class="fc" id="L794">        final String dpad = createPadding(descPad);</span>

        // first create list containing only &lt;lpad&gt;-a,--aaa where 
        // -a is opt and --aaa is long opt; in parallel look for 
        // the longest opt string this list will be then used to 
        // sort options ascending
<span class="fc" id="L800">        int max = 0;</span>
<span class="fc" id="L801">        List&lt;StringBuffer&gt; prefixList = new ArrayList&lt;StringBuffer&gt;();</span>

<span class="fc" id="L803">        List&lt;Option&gt; optList = options.helpOptions();</span>

<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L807">            Collections.sort(optList, getOptionComparator());</span>
        }

<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (Option option : optList)</span>
        {
<span class="fc" id="L812">            StringBuffer optBuf = new StringBuffer();</span>

<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (option.getOpt() == null)</span>
            {
<span class="fc" id="L816">                optBuf.append(lpad).append(&quot;   &quot;).append(getLongOptPrefix()).append(option.getLongOpt());</span>
            }
            else
            {
<span class="fc" id="L820">                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());</span>

<span class="fc bfc" id="L822" title="All 2 branches covered.">                if (option.hasLongOpt())</span>
                {
<span class="fc" id="L824">                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());</span>
                }
            }

<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (option.hasArg())</span>
            {
<span class="fc" id="L830">                String argName = option.getArgName();</span>
<span class="pc bpc" id="L831" title="1 of 4 branches missed.">                if (argName != null &amp;&amp; argName.length() == 0)</span>
                {
                    // if the option has a blank argname
<span class="nc" id="L834">                    optBuf.append(' ');</span>
                }
                else
                {
<span class="fc bfc" id="L838" title="All 2 branches covered.">                    optBuf.append(option.hasLongOpt() ? longOptSeparator : &quot; &quot;);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">                    optBuf.append(&quot;&lt;&quot;).append(argName != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
                }
            }

<span class="fc" id="L843">            prefixList.add(optBuf);</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">            max = optBuf.length() &gt; max ? optBuf.length() : max;</span>
<span class="fc" id="L845">        }</span>

<span class="fc" id="L847">        int x = 0;</span>

<span class="fc bfc" id="L849" title="All 2 branches covered.">        for (Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
<span class="fc" id="L851">            Option option = it.next();</span>
<span class="fc" id="L852">            StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());</span>

<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (optBuf.length() &lt; max)</span>
            {
<span class="fc" id="L856">                optBuf.append(createPadding(max - optBuf.length()));</span>
            }

<span class="fc" id="L859">            optBuf.append(dpad);</span>

<span class="fc" id="L861">            int nextLineTabStop = max + descPad;</span>

<span class="pc bpc" id="L863" title="1 of 2 branches missed.">            if (option.getDescription() != null)</span>
            {
<span class="fc" id="L865">                optBuf.append(option.getDescription());</span>
            }

<span class="fc" id="L868">            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());</span>

<span class="fc bfc" id="L870" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L872">                sb.append(getNewLine());</span>
            }
<span class="fc" id="L874">        }</span>

<span class="fc" id="L876">        return sb;</span>
    }

    /**
     * Render the specified text and return the rendered Options
     * in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderWrappedText(StringBuffer sb, int width, 
                                             int nextLineTabStop, String text)
    {
<span class="fc" id="L893">        int pos = findWrapPos(text, width, 0);</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (pos == -1)</span>
        {
<span class="fc" id="L897">            sb.append(rtrim(text));</span>

<span class="fc" id="L899">            return sb;</span>
        }
<span class="fc" id="L901">        sb.append(rtrim(text.substring(0, pos))).append(getNewLine());</span>

<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (nextLineTabStop &gt;= width)</span>
        {
            // stops infinite loop happening
<span class="fc" id="L906">            nextLineTabStop = 1;</span>
        }

        // all following lines must be padded with nextLineTabStop space characters
<span class="fc" id="L910">        final String padding = createPadding(nextLineTabStop);</span>

        while (true)
        {
<span class="fc" id="L914">            text = padding + text.substring(pos).trim();</span>
<span class="fc" id="L915">            pos = findWrapPos(text, width, 0);</span>

<span class="fc bfc" id="L917" title="All 2 branches covered.">            if (pos == -1)</span>
            {
<span class="fc" id="L919">                sb.append(text);</span>

<span class="fc" id="L921">                return sb;</span>
            }

<span class="fc bfc" id="L924" title="All 4 branches covered.">            if (text.length() &gt; width &amp;&amp; pos == nextLineTabStop - 1)</span>
            {
<span class="fc" id="L926">                pos = width;</span>
            }

<span class="fc" id="L929">            sb.append(rtrim(text.substring(0, pos))).append(getNewLine());</span>
        }
    }

    /**
     * Render the specified text width a maximum width. This method differs
     * from renderWrappedText by not removing leading spaces after a new line.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     */
    private Appendable renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text)
    {
        try
        {
<span class="fc" id="L946">            BufferedReader in = new BufferedReader(new StringReader(text));</span>
            String line;
<span class="fc" id="L948">            boolean firstLine = true;</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">            while ((line = in.readLine()) != null)</span>
            {
<span class="fc bfc" id="L951" title="All 2 branches covered.">                if (!firstLine)</span>
                {
<span class="fc" id="L953">                    sb.append(getNewLine());</span>
                }
                else
                {
<span class="fc" id="L957">                    firstLine = false;</span>
                }
<span class="fc" id="L959">                renderWrappedText(sb, width, nextLineTabStop, line);</span>
            }
        }
<span class="nc" id="L962">        catch (IOException e) //NOPMD</span>
        {
            // cannot happen
<span class="fc" id="L965">        }</span>

<span class="fc" id="L967">        return sb;</span>
    }

    /**
     * Finds the next text wrap position after &lt;code&gt;startPos&lt;/code&gt; for the
     * text in &lt;code&gt;text&lt;/code&gt; with the column width &lt;code&gt;width&lt;/code&gt;.
     * The wrap point is the last position before startPos+width having a 
     * whitespace character (space, \n, \r). If there is no whitespace character
     * before startPos+width, it will return startPos+width.
     *
     * @param text The text being searched for the wrap position
     * @param width width of the wrapped text
     * @param startPos position from which to start the lookup whitespace
     * character
     * @return position on which the text must be wrapped or -1 if the wrap
     * position is at the end of the text
     */
    protected int findWrapPos(String text, int width, int startPos)
    {
        // the line ends before the max wrap pos or a new line char found
<span class="fc" id="L987">        int pos = text.indexOf('\n', startPos);</span>
<span class="fc bfc" id="L988" title="All 4 branches covered.">        if (pos != -1 &amp;&amp; pos &lt;= width)</span>
        {
<span class="fc" id="L990">            return pos + 1;</span>
        }

<span class="fc" id="L993">        pos = text.indexOf('\t', startPos);</span>
<span class="pc bpc" id="L994" title="1 of 4 branches missed.">        if (pos != -1 &amp;&amp; pos &lt;= width)</span>
        {
<span class="fc" id="L996">            return pos + 1;</span>
        }

<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (startPos + width &gt;= text.length())</span>
        {
<span class="fc" id="L1001">            return -1;</span>
        }

        // look for the last whitespace character before startPos+width
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        for (pos = startPos + width; pos &gt;= startPos; --pos)</span>
        {
<span class="fc" id="L1007">            final char c = text.charAt(pos);</span>
<span class="pc bpc" id="L1008" title="2 of 6 branches missed.">            if (c == ' ' || c == '\n' || c == '\r')</span>
            {
<span class="nc" id="L1010">                break;</span>
            }
        }

        // if we found it - just return
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (pos &gt; startPos)</span>
        {
<span class="fc" id="L1017">            return pos;</span>
        }

        // if we didn't find one, simply chop at startPos+width
<span class="fc" id="L1021">        pos = startPos + width;</span>

<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">        return pos == text.length() ? -1 : pos;</span>
    }

    /**
     * Return a String of padding of length &lt;code&gt;len&lt;/code&gt;.
     *
     * @param len The length of the String of padding to create.
     *
     * @return The String of padding
     */
    protected String createPadding(int len)
    {
<span class="fc" id="L1035">        char[] padding = new char[len];</span>
<span class="fc" id="L1036">        Arrays.fill(padding, ' ');</span>

<span class="fc" id="L1038">        return new String(padding);</span>
    }

    /**
     * Remove the trailing whitespace from the specified String.
     *
     * @param s The String to remove the trailing padding from.
     *
     * @return The String of without the trailing padding
     */
    protected String rtrim(String s)
    {
<span class="fc bfc" id="L1050" title="All 4 branches covered.">        if (s == null || s.length() == 0)</span>
        {
<span class="fc" id="L1052">            return s;</span>
        }

<span class="fc" id="L1055">        int pos = s.length();</span>

<span class="pc bpc" id="L1057" title="1 of 4 branches missed.">        while (pos &gt; 0 &amp;&amp; Character.isWhitespace(s.charAt(pos - 1)))</span>
        {
<span class="fc" id="L1059">            --pos;</span>
        }

<span class="fc" id="L1062">        return s.substring(0, pos);</span>
    }

    // ------------------------------------------------------ Package protected
    // ---------------------------------------------------------------- Private
    // ---------------------------------------------------------- Inner classes
    /**
     * This class implements the &lt;code&gt;Comparator&lt;/code&gt; interface
     * for comparing Options.
     */
<span class="fc" id="L1072">    private static class OptionComparator implements Comparator&lt;Option&gt;, Serializable</span>
    {
        /** The serial version UID. */
        private static final long serialVersionUID = 5305467873966684014L;

        /**
         * Compares its two arguments for order. Returns a negative
         * integer, zero, or a positive integer as the first argument
         * is less than, equal to, or greater than the second.
         *
         * @param opt1 The first Option to be compared.
         * @param opt2 The second Option to be compared.
         * @return a negative integer, zero, or a positive integer as
         *         the first argument is less than, equal to, or greater than the
         *         second.
         */
        public int compare(Option opt1, Option opt2)
        {
<span class="fc" id="L1090">            return opt1.getKey().compareToIgnoreCase(opt2.getKey());</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>